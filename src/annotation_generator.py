# annotation_generator.py
from src.pgn_parser import PGNTreeNode, parse_pgn_to_tree
from src.stockfish_interface import StockfishAnalyzer
from src.prompt_engineering import create_annotation_prompt
from src.chatgpt_interface import get_annotation_from_chatgpt

def annotate_tree(node: PGNTreeNode, analyzer: StockfishAnalyzer, ply_depth: int):
    """
    Annotate a PGNTreeNode with commentary generated by ChatGPT.
    Since the PGN is now linear, this only processes the main line.
    """
    fen = node.board.fen()
    # Build evaluation tree for the current position
    eval_tree = analyzer.build_eval_tree(node.board, ply_depth)
    # Create prompt with FEN and evaluation tree
    prompt = create_annotation_prompt(fen, eval_tree)
    # Get annotation from ChatGPT
    annotation = get_annotation_from_chatgpt(prompt)
    node.annotation = annotation

    # Only annotate the first (and only) child, if present
    if node.children:
        annotate_tree(node.children[0], analyzer, ply_depth)

def generate_annotations_for_game(pgn_file: str, ply_depth: int):
    """
    Parse a PGN file, annotate the main line of the game with commentary,
    and return the annotated tree.
    """
    root = parse_pgn_to_tree(pgn_file)
    analyzer = StockfishAnalyzer()
    annotate_tree(root, analyzer, ply_depth)
    analyzer.close()
    return root

# For testing:
if __name__ == "__main__":
    tree = generate_annotations_for_game("data/raw/sample.pgn", ply_depth=2)
    print("Root annotation:")
    print(tree.annotation)
    if tree.children:
        print("First move annotation:")
        print(tree.children[0].annotation)
